import tkinter as tk
from tkinter import ttk, messagebox
import sys
import os
import re
from settings_window import SettingsWindow

THEME = {
    "bg": "#1a1a2e",
    "bg_secondary": "#16213e",
    "bg_card": "#0f3460",
    "accent": "#00d4ff",
    "accent_hover": "#00b8e6",
    "success": "#00ff88",
    "warning": "#ff6b6b",
    "text": "#e4e4e4",
    "text_dim": "#a0a0a0",
    "border": "#2a2a4e",
    "font_main": ("Segoe UI", 10),
    "font_header": ("Segoe UI", 16, "bold"),
    "font_subheader": ("Segoe UI", 12, "bold"),
    "font_mono": ("Consolas", 9),
}


class ModernButton(tk.Button):
    def __init__(self, master, **kwargs):
        style = kwargs.pop('style', 'primary')
        super().__init__(master, **kwargs)
        
        if style == 'primary':
            bg_color = THEME["accent"]
            hover_color = THEME["accent_hover"]
            fg_color = THEME["bg"]
        elif style == 'success':
            bg_color = THEME["success"]
            hover_color = "#00e67a"
            fg_color = THEME["bg"]
        elif style == 'danger':
            bg_color = THEME["warning"]
            hover_color = "#ff5252"
            fg_color = "white"
        else:
            bg_color = THEME["bg_card"]
            hover_color = THEME["border"]
            fg_color = THEME["text"]
        
        self.config(
            bg=bg_color,
            fg=fg_color,
            activebackground=hover_color,
            activeforeground=fg_color,
            font=THEME["font_main"],
            bd=0,
            relief="flat",
            padx=20,
            pady=10,
            cursor="hand2"
        )
        
        self.bind("<Enter>", lambda e: self.config(bg=hover_color))
        self.bind("<Leave>", lambda e: self.config(bg=bg_color))


class Overlay(tk.Toplevel):
    def __init__(self, master, state, save_config):
        super().__init__(master)
        self.state = state
        self.save_config = save_config
        self.overrideredirect(True)
        self.attributes("-topmost", True, "-alpha", 0.92)
        self.config(bg=THEME["bg_secondary"])
        
        container = tk.Frame(self, bg=THEME["bg_secondary"], padx=15, pady=10)
        container.pack(fill="both", expand=True)
        
        self.lbl_status = tk.Label(
            container,
            text="‚óè ONLINE",
            font=("Segoe UI", 9, "bold"),
            bg=THEME["bg_secondary"],
            fg=THEME["success"],
        )
        self.lbl_status.pack(anchor="w")
        
        self.lbl_macro = tk.Label(
            container,
            text="",
            font=("Segoe UI", 9, "bold"),
            bg=THEME["bg_secondary"],
            fg=THEME["warning"],
        )
        self.lbl_macro.pack(anchor="w")
        
        self.geometry(
            f"160x60+{state['config']['overlay_x']}+{state['config']['overlay_y']}"
        )
        self.bind("<Button-1>", self.start_move)
        self.bind("<B1-Motion>", self.do_move)
        self.bind("<ButtonRelease-1>", self.stop_move)

    def start_move(self, event):
        self.x = event.x
        self.y = event.y

    def do_move(self, event):
        x = self.winfo_x() + (event.x - self.x)
        y = self.winfo_y() + (event.y - self.y)
        self.geometry(f"+{x}+{y}")

    def stop_move(self, event):
        self.state["config"]["overlay_x"] = self.winfo_x()
        self.state["config"]["overlay_y"] = self.winfo_y()
        self.save_config()


def update_overlay(state):
    if not state["overlay_ref"] or not state["overlay_ref"].winfo_exists():
        return
    ov = state["overlay_ref"]
    if state["config"]["overlay_enabled"]:
        ov.deiconify()
        ov.lbl_status.config(
            text="‚óè OFFLINE" if state["is_lagging"] else "‚óè ONLINE",
            fg=THEME["warning"] if state["is_lagging"] else THEME["success"],
        )
        macro_text = (
            "‚ñ∂ RUNNING"
            if state["is_running_macro"]
            else (
                "‚ñ† DISABLED" if not state["config"].get("macro_enabled", True) else ""
            )
        )
        ov.lbl_macro.config(
            text=macro_text,
            fg=THEME["text_dim"] if macro_text == "‚ñ† DISABLED" else THEME["accent"],
        )
    else:
        ov.withdraw()


class App(tk.Tk):
    def __init__(self, state, save_config, get_active_network_interfaces):
        super().__init__()
        self.state = state
        self.save_config_func = save_config
        self.get_active_network_interfaces = get_active_network_interfaces

        self.title("Macro Controller")
        self.geometry("380x750")
        self.configure(bg=THEME["bg"])
        self.attributes("-topmost", True)
        
        style = ttk.Style()
        style.theme_use('clam')
        style.configure("Modern.TCombobox",
                       fieldbackground=THEME["bg_card"],
                       background=THEME["bg_card"],
                       foreground=THEME["text"],
                       bordercolor=THEME["border"],
                       arrowcolor=THEME["accent"],
                       selectbackground=THEME["accent"],
                       selectforeground=THEME["bg"])
        
        self.canvas = tk.Canvas(self, bg=THEME["bg"], highlightthickness=0)
        self.scrollbar = tk.Scrollbar(
            self, orient="vertical", command=self.canvas.yview,
            bg=THEME["bg_secondary"], troughcolor=THEME["bg"],
            activebackground=THEME["accent"]
        )
        self.scrollable_frame = tk.Frame(self.canvas, bg=THEME["bg"])

        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all")),
        )

        self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        self.canvas.configure(yscrollcommand=self.scrollbar.set)

        self.canvas.pack(side="left", fill="both", expand=True)
        self.scrollbar.pack(side="right", fill="y")

        self.canvas.bind_all("<MouseWheel>", self._on_mousewheel)

        header_frame = tk.Frame(self.scrollable_frame, bg=THEME["bg"])
        header_frame.pack(pady=(20, 5), fill="x", padx=25)
        
        title_label = tk.Label(
            header_frame,
            text="Macro Controller",
            font=THEME["font_header"],
            bg=THEME["bg"],
            fg=THEME["accent"],
        )
        title_label.pack(side="left")
        
        settings_btn = tk.Button(
            header_frame,
            text="‚öô",
            font=("Segoe UI", 18),
            bg=THEME["bg"],
            fg=THEME["accent"],
            bd=0,
            cursor="hand2",
            command=self.open_settings,
            activebackground=THEME["bg"],
            activeforeground=THEME["accent_hover"]
        )
        settings_btn.pack(side="right", padx=5)
        
        subtitle = tk.Label(
            self.scrollable_frame,
            text="Configure and control your macros",
            font=("Segoe UI", 9),
            bg=THEME["bg"],
            fg=THEME["text_dim"],
        )
        subtitle.pack(pady=(0, 20), padx=25)

        self.frame = tk.Frame(self.scrollable_frame, bg=THEME["bg"])
        self.frame.pack(fill="both", expand=True, padx=25, pady=(0, 20))
        self.build_ui()
        self.state["overlay_ref"] = Overlay(self, self.state, self.save_config_func)
        update_overlay(self.state)

    def _on_mousewheel(self, event):
        self.canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")

    def open_settings(self):
        SettingsWindow(self, self.state, self.save_config_func)

    def build_ui(self):
        keys = (
            [chr(i) for i in range(97, 123)]
            + [str(i) for i in range(10)]
            + [f"Key.f{i}" for i in range(1, 13)]
        )
        clumsy_keys = [chr(i) for i in range(97, 123)] + [str(i) for i in range(10)]

        def create_card(title, icon=""):
            card = tk.Frame(self.frame, bg=THEME["bg_card"], padx=15, pady=15)
            card.pack(fill="x", pady=(0, 15))
            
            header = tk.Frame(card, bg=THEME["bg_card"])
            header.pack(fill="x", pady=(0, 10))
            
            if icon:
                tk.Label(header, text=icon, font=("Segoe UI", 14),
                        bg=THEME["bg_card"], fg=THEME["accent"]).pack(side="left", padx=(0, 8))
            
            tk.Label(header, text=title, font=THEME["font_subheader"],
                    bg=THEME["bg_card"], fg=THEME["text"]).pack(side="left")
            
            return card
        
        def add_label(parent, text):
            tk.Label(
                parent,
                text=text,
                bg=THEME["bg_card"],
                fg=THEME["text"],
                font=THEME["font_main"],
                anchor="w"
            ).pack(fill="x", pady=(8, 3))
        
        def add_combobox(parent, values, default):
            cb = ttk.Combobox(
                parent,
                values=values,
                font=THEME["font_mono"],
                style="Modern.TCombobox",
                state="readonly"
            )
            cb.set(default)
            cb.pack(fill="x", pady=(0, 8))
            return cb

        net_card = create_card("Network Configuration", "üåê")
        
        add_label(net_card, "Network Method")
        self.cb_net_method = add_combobox(
            net_card,
            ["netsh", "Clumsy"],
            self.state["config"].get("network_method", "netsh")
        )
        self.cb_net_method.bind("<<ComboboxSelected>>", self.on_method_change)

        self.frame_netsh = tk.Frame(self.frame, bg=THEME["bg"])
        self.frame_clumsy = tk.Frame(self.frame, bg=THEME["bg"])

        self.lbl_iface = tk.Label(
            self.frame_netsh,
            text="NETWORK INTERFACE:",
            bg=THEME["bg"],
            fg=THEME["fg"],
            font=THEME["font_mono"],
        )
        self.lbl_iface.pack(anchor="w", padx=0)

        active_interfaces = self.get_active_network_interfaces()
        interface_values = []
        for iface in active_interfaces:
            interface_values.append(f"{iface['name']} ({iface['type']})")

        if not interface_values:
            interface_values = ["No active interfaces detected"]

        self.cb_iface = ttk.Combobox(
            self.frame_netsh,
            values=interface_values,
            font=THEME["font_mono"],
            state="readonly",
        )

        current_iface = self.state["config"].get("net_interface", "")
        current_type = self.state["config"].get("net_interface_type", "Unknown")

        selected = False
        if current_iface:
            for iface_display in interface_values:
                if current_iface in iface_display:
                    self.cb_iface.set(iface_display)
                    selected = True
                    break

        if not selected:
            if (
                interface_values
                and interface_values[0] != "No active interfaces detected"
            ):
                self.cb_iface.set(interface_values[0])
            elif current_iface:
                self.cb_iface.set(f"{current_iface} ({current_type})")

        self.cb_iface.pack(fill="x", pady=2, padx=0)

        self.btn_refresh = HackerButton(
            self.frame_netsh,
            text="REFRESH INTERFACES",
            command=self.refresh_interfaces,
            bg="#003333",
        )
        self.btn_refresh.pack(fill="x", pady=2, padx=0)

        self.lbl_clumsy = tk.Label(
            self.frame_clumsy,
            text="CLUMSY HOTKEY:",
            bg=THEME["bg"],
            fg=THEME["fg"],
            font=THEME["font_mono"],
        )
        self.lbl_clumsy.pack(anchor="w", padx=0)
        self.cb_clumsy_key = ttk.Combobox(
            self.frame_clumsy, values=clumsy_keys, font=THEME["font_mono"]
        )
        self.cb_clumsy_key.set(self.state["config"].get("clumsy_hotkey", "8"))
        self.cb_clumsy_key.pack(fill="x", pady=2, padx=0)

        self.update_method_display()

        tk.Label(
            self.frame,
            text="TRIGGER KEY:",
            bg=THEME["bg"],
            fg=THEME["fg"],
            font=THEME["font_mono"],
        ).pack(anchor="w", pady=(10, 0), padx=0)
        self.cb_trig = ttk.Combobox(self.frame, values=keys, font=THEME["font_mono"])
        self.cb_trig.set(self.state["config"]["key_macro_trigger"])
        self.cb_trig.pack(fill="x", pady=2, padx=0)

        tk.Label(
            self.frame,
            text="DISCONNECT TIMING:",
            bg=THEME["bg"],
            fg=THEME["fg"],
            font=THEME["font_mono"],
        ).pack(anchor="w", pady=(10, 0), padx=0)
        self.cb_disc_mode = ttk.Combobox(
            self.frame,
            values=["After Click Start", "Before Click Start"],
            font=THEME["font_mono"],
        )
        self.cb_disc_mode.set(
            self.state["config"].get("macro_disconnect_mode", "Before Click Start")
        )
        self.cb_disc_mode.pack(fill="x", pady=2, padx=0)

        tk.Label(
            self.frame,
            text="CLICKS PER SECOND (CPS):",
            bg=THEME["bg"],
            fg=THEME["fg"],
            font=THEME["font_mono"],
        ).pack(anchor="w", pady=(10, 0), padx=0)
        self.s_cps = tk.Scale(
            self.frame,
            from_=1,
            to=30,
            orient="horizontal",
            bg=THEME["bg"],
            fg="white",
            highlightthickness=0,
            troughcolor="#222",
        )
        self.s_cps.set(self.state["config"]["click_cps"])
        self.s_cps.pack(fill="x", padx=0)

        tk.Label(
            self.frame,
            text="THROW TRIGGER KEY:",
            bg=THEME["bg"],
            fg=THEME["fg"],
            font=THEME["font_mono"],
        ).pack(anchor="w", pady=(10, 0), padx=0)
        self.cb_throw_trig = ttk.Combobox(
            self.frame, values=keys, font=THEME["font_mono"]
        )
        self.cb_throw_trig.set(self.state["config"]["key_throw_trigger"])
        self.cb_throw_trig.pack(fill="x", pady=2, padx=0)

        tk.Label(
            self.frame,
            text="Fixed sequence: <3s total\nClumsy toggle ‚Üí Drag ‚Üí Tab ‚Üí E-spam",
            bg=THEME["bg"],
            fg="#888",
            font=("Consolas", 8),
            justify="left",
        ).pack(anchor="w", pady=2, padx=0)

        tk.Label(
            self.frame,
            text="THROW V2 TRIGGER KEY:",
            bg=THEME["bg"],
            fg=THEME["fg"],
            font=THEME["font_mono"],
        ).pack(anchor="w", pady=(10, 0), padx=0)
        self.cb_throw_v2_trig = ttk.Combobox(
            self.frame, values=keys, font=THEME["font_mono"]
        )
        self.cb_throw_v2_trig.set(self.state["config"].get("key_throw_v2_trigger", "Key.f7"))
        self.cb_throw_v2_trig.pack(fill="x", pady=2, padx=0)

        tk.Label(
            self.frame,
            text="Uses robust input method (SendInput)\nSame sequence as Throw v1",
            bg=THEME["bg"],
            fg="#888",
            font=("Consolas", 8),
            justify="left",
        ).pack(anchor="w", pady=2, padx=0)

        tk.Label(
            self.frame,
            text="RECORD TRIGGER KEY:",
            bg=THEME["bg"],
            fg=THEME["fg"],
            font=THEME["font_mono"],
        ).pack(anchor="w", pady=(10, 0), padx=0)
        self.cb_record_trig = ttk.Combobox(
            self.frame, values=keys, font=THEME["font_mono"]
        )
        self.cb_record_trig.set(self.state["config"]["key_record_trigger"])
        self.cb_record_trig.pack(fill="x", pady=2, padx=0)

        tk.Label(
            self.frame,
            text="PLAYBACK TRIGGER KEY:",
            bg=THEME["bg"],
            fg=THEME["fg"],
            font=THEME["font_mono"],
        ).pack(anchor="w", pady=(5, 0), padx=0)
        self.cb_playback_trig = ttk.Combobox(
            self.frame, values=keys, font=THEME["font_mono"]
        )
        self.cb_playback_trig.set(self.state["config"]["key_playback_trigger"])
        self.cb_playback_trig.pack(fill="x", pady=2, padx=0)

        tk.Label(
            self.frame,
            text="Press RECORD key to start/stop recording\nPress PLAYBACK key to replay",
            bg=THEME["bg"],
            fg="#888",
            font=("Consolas", 8),
            justify="left",
        ).pack(anchor="w", pady=2, padx=0)

        f_btn = tk.Frame(self.frame, bg=THEME["bg"])
        f_btn.pack(fill="x", pady=20, padx=0)
        self.btn_macro = HackerButton(
            f_btn, text="DISABLE MACRO", command=self.toggle_macro, bg="#003300"
        )
        self.btn_macro.pack(fill="x", pady=2, padx=0)
        self.btn_throw = HackerButton(
            f_btn, text="DISABLE THROW", command=self.toggle_throw, bg="#003300"
        )
        self.btn_throw.pack(fill="x", pady=2, padx=0)
        self.btn_recording = HackerButton(
            f_btn, text="DISABLE RECORDING", command=self.toggle_recording, bg="#003300"
        )
        self.btn_recording.pack(fill="x", pady=2, padx=0)
        HackerButton(f_btn, text="SAVE SETTINGS", command=self.save).pack(
            fill="x", pady=2, padx=0
        )
        self.btn_ov = HackerButton(
            f_btn, text="DISABLE OVERLAY", command=self.toggle_ov
        )
        self.btn_ov.pack(fill="x", pady=2, padx=0)
        HackerButton(
            f_btn,
            text="RELOAD TOOL",
            command=lambda: os.execv(sys.executable, [sys.executable] + sys.argv),
            bg="#330000",
        ).pack(fill="x", pady=2, padx=0)

    def save(self):
        c = self.state["config"]
        c["key_macro_trigger"] = self.cb_trig.get()
        c["macro_disconnect_mode"] = self.cb_disc_mode.get()
        c["click_cps"] = self.s_cps.get()
        c["network_method"] = self.cb_net_method.get()
        c["clumsy_hotkey"] = self.cb_clumsy_key.get()

        iface_selection = self.cb_iface.get()
        if iface_selection and iface_selection != "No active interfaces detected":
            match = re.match(r"^(.+?)\s*\((.+?)\)$", iface_selection)
            if match:
                c["net_interface"] = match.group(1).strip()
                c["net_interface_type"] = match.group(2).strip()
            else:
                c["net_interface"] = iface_selection
                c["net_interface_type"] = "Unknown"

        c["key_throw_trigger"] = self.cb_throw_trig.get()
        c["key_throw_v2_trigger"] = self.cb_throw_v2_trig.get()
        c["key_record_trigger"] = self.cb_record_trig.get()
        c["key_playback_trigger"] = self.cb_playback_trig.get()
        
        self.save_config_func()
        messagebox.showinfo("Saved", "Settings Updated!")

    def refresh_interfaces(self):
        """Refresh the list of active network interfaces"""
        active_interfaces = self.get_active_network_interfaces()
        interface_values = []
        for iface in active_interfaces:
            interface_values.append(f"{iface['name']} ({iface['type']})")

        if not interface_values:
            interface_values = ["No active interfaces detected"]

        self.cb_iface["values"] = interface_values
        if interface_values and interface_values[0] != "No active interfaces detected":
            self.cb_iface.set(interface_values[0])

        messagebox.showinfo(
            "Refresh", f"Found {len(active_interfaces)} active interface(s)"
        )

    def update_method_display(self):
        """Show/hide interface or clumsy settings based on selected method"""
        method = self.cb_net_method.get()

        self.frame_netsh.pack_forget()
        self.frame_clumsy.pack_forget()

        if method == "Clumsy":
            self.frame_clumsy.pack(after=self.cb_net_method, fill="x", pady=2)
        else:
            self.frame_netsh.pack(after=self.cb_net_method, fill="x", pady=2)

    def on_method_change(self, event=None):
        """Handle network method change"""
        self.update_method_display()

    def toggle_macro(self):
        self.state["config"]["macro_enabled"] = not self.state["config"].get(
            "macro_enabled", True
        )
        enabled = self.state["config"]["macro_enabled"]
        self.btn_macro.config(
            text="DISABLE MACRO" if enabled else "ENABLE MACRO",
            bg="#003300" if enabled else "#330000",
        )
        update_overlay(self.state)
        self.save_config_func()

    def toggle_throw(self):
        self.state["config"]["throw_enabled"] = not self.state["config"].get(
            "throw_enabled", True
        )
        enabled = self.state["config"]["throw_enabled"]
        self.btn_throw.config(
            text="DISABLE THROW" if enabled else "ENABLE THROW",
            bg="#003300" if enabled else "#330000",
        )
        self.save_config_func()

    def toggle_recording(self):
        self.state["config"]["recording_enabled"] = not self.state["config"].get(
            "recording_enabled", True
        )
        enabled = self.state["config"]["recording_enabled"]
        self.btn_recording.config(
            text="DISABLE RECORDING" if enabled else "ENABLE RECORDING",
            bg="#003300" if enabled else "#330000",
        )
        self.save_config_func()

    def toggle_ov(self):
        self.state["config"]["overlay_enabled"] = not self.state["config"][
            "overlay_enabled"
        ]
        self.btn_ov.config(
            text=(
                "DISABLE OVERLAY"
                if self.state["config"]["overlay_enabled"]
                else "ENABLE OVERLAY"
            )
        )
        update_overlay(self.state)
        self.save_config_func()
